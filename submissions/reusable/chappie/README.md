# Chappie Overview #

`chappie` is a fine-grained energy profiler for multi-threaded Java applications.
Below is an excerpt from our paper abstract about this work's motivation:

 > Energy accounting is a fundamental problem in energy management, defined as attributing global energy consumption to individual components of interest. In this paper, we take on this problem at the application level, where the components for accounting are **application logical units**, such as methods, classes, and packages. Given a Java application, our novel runtime system `chappie` produces an **energy footprint**, i.e., the relative energy consumption of all programming abstraction units within the application.

 > The design of `chappie` is unique in several dimensions. First, relative to targeted energy profiling where the profiler determines the energy consumption of a pre-defined application logical unit, e.g., a specific method, `chappie` is **total**: the energy footprint encompasses all methods within an application. Second, `chappie` is **concurrency aware**: energy attribution is fully aware of the multi-threaded behavior of Java applications, including JVM bookkeeping threads. Third, `chappie` is an embodiment of a novel philosophy for application-level energy accounting and profiling, which states that the accounting run should preserve the **temporal** phased power behavior of the application, and the **spatial** power distribution among the underlying hardware system. We term this important property as **calmness**. Against state-of-the-art DaCapo benchmarks, we show that the energy footprint generated by `chappie` is precise while incurring negligible overhead. In addition, all results are produced with a high degree of calmness.

 # Experiment reproduction: Docker-based execution #

 Our publication data can be reproduced using a docker image. You can either run the image from docker hub:

 ```bash
 docker run --privileged --cap-add=ALL -it -v /dev:/dev -v /lib/modules:/lib/modules chappie-fse20
 ```

 or build and run the provided `Dockerfile`:

 ```bash
 docker build -t chappie-fse20 .
 docker run --privileged --cap-add=ALL -it -v /dev:/dev -v /lib/modules:/lib/modules chappie-fse20
 ```

 After execution finishes, output data can be found at `./chappie/chappie-data` inside the container.

 **NOTE**: The data reported in the paper was produced through an evaluation with the system described below. As energy consumption varies from system to system, e.g., the number of cores, the OS schedulers, the JVM runtime behavior, etc., a reproduction on a different system may not produce identical results as we reported in the paper. Specifically, `chappie` requires the use of [RAPL](https://en.wikipedia.org/wiki/Perf_(Linux)#RAPL), which only works on Intel cpus:

 > - Dual socket Intel E5-2630 v4 2.20 GHz (20 cores)
 > - Hyper threading enabled
 > - 64 GB DDR4 RAM
 > - Debian 4.9 (linux kernel 4.9)
 > - Debian default `powersave` governor
 > - Java 11 Hotspot VM build 11.0.2+9-LTS

# Experiment reproduction: Building from source #

If you prefer to build `chappie` from source, please follow the instructions at our [public repository](https://github.com/pl-chappie/chappie).
